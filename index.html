<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Alphabet Learning App</title>
<link rel="stylesheet" href="style.css">
</head>
<body>
<div id="fileProtocolNotice" style="display:none;position:sticky;top:0;z-index:9999;background:#f0ad4e;color:#000;padding:8px 12px;font-size:14px;text-align:center;box-shadow:0 2px 4px rgba(0,0,0,.2)">
  <span id="fileProtocolNoticeText"></span>
  <button onclick="document.getElementById('fileProtocolNotice').style.display='none'" style="margin-left:8px;cursor:pointer">Dismiss</button>
</div>
<header>
  <div id="title"></div>
  <button onclick="openSettings()">⚙️</button>
</header>

<!-- ================= ALPHABET ================= -->
<div id="alphabetScreen" class="screen active">
  <div id="alphabetGrid" class="grid"></div>
  <div style="display:flex;justify-content:space-around;margin-top:10px">
    <button id="btnSounds" onclick="showScreen('soundsScreen')"></button>
    <button id="btnVocab" onclick="showScreen('vocabScreen')"></button>
    <button id="btnReading" onclick="showScreen('readingScreen')"></button>
    <button id="btnDict" onclick="showScreen('dictScreen')"></button>
  </div>
</div>

<!-- ================= SOUNDS ================= -->
<div id="soundsScreen" class="screen">
  <button onclick="showScreen('alphabetScreen')" id="sndBack"></button>
  <h2 id="sndTitle"></h2>
  <div id="soundsGrid" class="grid"></div>
  <br>
  <button onclick="openPractice('Sounds')" id="sndPractice"></button>
</div>

<!-- ================= VOCAB ================= -->
<div id="vocabScreen" class="screen">
  <button onclick="showScreen('alphabetScreen')">←</button>
  <h2 id="vocabTitle"></h2>
  <button onclick="openPractice('Vocab','Speaking')" id="speakBtn"></button><br><br>
  <button onclick="openPractice('Vocab','Listening')" id="listenBtn"></button><br><br>
  <button onclick="openPractice('Vocab','Both')" id="bothBtn"></button>
</div>

<!-- ================= PRACTICE ================= -->
<div id="practiceScreen" class="screen">
  <div>
    <span id="lblMax"></span>
    <select id="maxSounds">
      <option value="Any">Any</option>
      <option value="1">1</option><option value="2">2</option>
      <option value="3">3</option><option value="4">4</option>
    </select>
    |
    <label>
      <input type="checkbox" id="realOnly">
      <span id="lblReal"></span>
    </label>
    |
    <button onclick="exitPractice()" id="practiceBack"></button>
  </div>
  <hr>
  <div id="practiceCard"></div>
</div>

<!-- ================= READING ================= -->
<div id="readingScreen" class="screen">
  <button onclick="showScreen('alphabetScreen')">←</button>
  <h2 id="readingTitle"></h2>
  <button id="fullDictionaryBtn" style="display:block;margin-bottom:8px;width:100%;" onclick="openStory(0)">Full Dictionary</button>
  <input id="storySearch" type="text" placeholder="Search stories…" oninput="renderStoryList()">
  <div id="readingCefrContainer" style="margin:8px 0 4px 0;display:flex;align-items:center;gap:8px;">
    <span id="readingCefrLabel" style="font-weight:bold"></span>
    <div id="readingCefrFilters" style="display:inline-flex;gap:4px;flex-wrap:wrap;"></div>
  </div>
  <div id="storyList"></div>
</div>

<div id="storyScreen" class="screen">
  <button onclick="showScreen('readingScreen')">←</button>
  <button id="colorModeBtn" onclick="toggleColorMode()"></button>
  <button id="autoReadBtn" onclick="toggleAutoRead()" oncontextmenu="resetAutoRead();return false;"></button>
  <hr>
  <div id="fullDictOptions" style="display:none;margin-bottom:8px;"></div>
  <div id="storyText"></div>
</div>

<!-- ================= DICTIONARY ================= -->
<div id="dictScreen" class="screen">
  <button onclick="showScreen('alphabetScreen')">←</button>
  <h2 id="dictTitle"></h2>
  <input id="dictSearch" oninput="renderDictionary()">
  <div id="cefrButtons"></div>
  <div id="dictList"></div>
</div>

<!-- ================= FAQ ================= -->
<div id="faqScreen" class="screen">
  <button onclick="showScreen('alphabetScreen')">←</button>
  <h2>FAQ</h2>
  <button id="faq0" onclick="openFAQ(0)"></button><br><br>
  <button id="faq1" onclick="openFAQ(1)"></button><br><br>
  <button id="faq2" onclick="openFAQ(2)"></button>
</div>

<!-- ================= SETTINGS ================= -->
<div id="settingsModal" class="modal">
  <div class="modal-box modal-box--settings">
    <button class="close" onclick="closeSettings()">✖</button>
    <button onclick="showScreen('faqScreen');closeSettings()">FAQ</button><br><br>
    <button onclick="toggleLang()" id="langBtn"></button><br><br>
    <button onclick="togglePhon()" id="phonBtn"></button>
    <div class="settings-version">Version 0.8: Reading Update</div>
  </div>
</div>

<!-- ================= INFO MODAL ================= -->
<div id="infoModal" class="modal">
  <div class="modal-box">
    <button class="close" onclick="closeInfo()">✖</button>
    <div id="infoContent"></div>
  </div>
</div>
<div id="letterNotesModal" class="modal">
  <div class="modal-box">
    <button class="close" onclick="closeLetterNotes()">✖</button>
    <div id="letterNotesContent"></div>
  </div>
</div>

<!--<script src="characters.js"></script>-->
<script src="scripts/faq.js"></script>
<script src="scripts/practice.js"></script>
<script src="scripts/state.js"></script>
<script>
// Resolve audio paths relative to the current page (fixes audio when opened via file:// or from GitHub Pages).
function resolveAssetUrl(path) { if (!path) return path; try { return new URL(path, window.location.href).href; } catch (e) { return path; } }
</script>
<script src="scripts/stories.js"></script>
<script src="scripts/translations.js"></script>
<script src="scripts/words.js"></script>
<script src="scripts/notes/letter_a.js"></script>
<script src="scripts/notes/letter_b.js"></script>
<script src="scripts/notes/letter_c.js"></script>
<script src="scripts/notes/letter_d.js"></script>
<script src="scripts/notes/letter_e.js"></script>
<script src="scripts/notes/letter_f.js"></script>
<script src="scripts/notes/letter_g.js"></script>
<script src="scripts/notes/letter_h.js"></script>
<script src="scripts/notes/letter_i.js"></script>
<script src="scripts/notes/letter_j.js"></script>
<script src="scripts/notes/letter_k.js"></script>
<script src="scripts/notes/letter_l.js"></script>
<script src="scripts/notes/letter_m.js"></script>
<script src="scripts/notes/letter_n.js"></script>
<script src="scripts/notes/letter_o.js"></script>
<script src="scripts/notes/letter_p.js"></script>
<script src="scripts/notes/letter_q.js"></script>
<script src="scripts/notes/letter_r.js"></script>
<script src="scripts/notes/letter_s.js"></script>
<script src="scripts/notes/letter_t.js"></script>
<script src="scripts/notes/letter_u.js"></script>
<script src="scripts/notes/letter_v.js"></script>
<script src="scripts/notes/letter_w.js"></script>
<script src="scripts/notes/letter_x.js"></script>
<script src="scripts/notes/letter_y.js"></script>
<script src="scripts/notes/letter_z.js"></script>

<script>
/* ================= UTIL ================= */
if (window.location.protocol === "file:") {
  var fileNotice = document.getElementById("fileProtocolNotice");
  var fileNoticeText = document.getElementById("fileProtocolNoticeText");
  if (fileNotice && fileNoticeText) {
    fileNoticeText.textContent = "Audio may not work when opening the file directly. For sound, run a local server (e.g. \"npx serve\" in this folder) and open the URL in your browser.";
    fileNotice.style.display = "block";
  }
}
const $=id=>document.getElementById(id);
function showScreen(id){
 document.querySelectorAll(".screen").forEach(s=>s.classList.remove("active"));
 $(id).classList.add("active");
}
function openSettings(){ $("settingsModal").style.display="flex"; }
function closeSettings(){ $("settingsModal").style.display="none"; }
const infoStack = [];
function closeInfo(){
  if (infoStack.length > 0) {
    $("infoContent").innerHTML = infoStack.pop();
  } else {
    $("infoModal").style.display = "none";
  }
}
function initAudioGainGraph() {
  if (state.audioGainNode) return;
  try {
    var ctx = new (window.AudioContext || window.webkitAudioContext)();
    var src = ctx.createMediaElementSource(state.audio);
    var gainNode = ctx.createGain();
    src.connect(gainNode);
    gainNode.connect(ctx.destination);
    state.audioContext = ctx;
    state.audioGainNode = gainNode;
  } catch (e) {}
}
function applyAudioVolume(volumeDb) {
  initAudioGainGraph();
  if (state.audioGainNode) {
    var db = (volumeDb != null && !isNaN(volumeDb)) ? Number(volumeDb) : 0;
    state.audioGainNode.gain.value = Math.pow(10, db / 20);
  }
}
function playSound(f, volumeDb){ applyAudioVolume(volumeDb != null ? volumeDb : 0); state.audio.src=resolveAssetUrl(f); state.audio.play(); }
function openInfo(html){
  const modal = $("infoModal");
  if (modal.style.display === "flex") {
    infoStack.push($("infoContent").innerHTML);
  }
  $("infoContent").innerHTML = html;
  modal.style.display = "flex";
}

function openStory(i) {
  state.currentStoryIndex = i;
  var story = typeof STORIES !== "undefined" ? STORIES[i] : null;
  if (!story) return;
  function doOpen() {
    if (story.dynamic === "fullDictionary" && typeof getFullDictionaryLines === "function") {
      story = { title: "Full Dictionary", lines: getFullDictionaryLines() };
    }
    var el = document.getElementById("storyText");
    var optsEl = document.getElementById("fullDictOptions");
    if (optsEl) {
      optsEl.style.display = i === 0 ? "block" : "none";
      optsEl.innerHTML = "";
      if (i === 0) {
        var label = document.createElement("label");
        var cb = document.createElement("input");
        cb.type = "checkbox";
        cb.checked = state.fullDictOnlyMissingAudio;
        cb.onchange = function() {
          state.fullDictOnlyMissingAudio = cb.checked;
          openStory(0);
        };
        label.appendChild(cb);
        label.appendChild(document.createTextNode(" " + (typeof TEXT !== "undefined" && TEXT[state.lang] && TEXT[state.lang].fullDictOnlyMissingAudio ? TEXT[state.lang].fullDictOnlyMissingAudio : "Show only words needing audio")));
        optsEl.appendChild(label);
      }
    }
    if (!story.lines || !el) return;
    el.innerHTML = "";
    state.autoIndex = 0;
    var h2 = document.createElement("h2");
    h2.textContent = story.title;
    h2.className = "story-title";
    el.appendChild(h2);
    // Find longest phrase in WORDS (or extended list including story-only words) starting at tokens[start] (handles "déjà vu" etc.)
    // variantHint: e.g. "read1", "bow2" – when multiple entries exist for same word, return the one matching this variant.
    function findWordEntry(tokens, start, variantHint) {
      var wordsList = (typeof getExtendedWords === "function" ? getExtendedWords() : (typeof WORDS !== "undefined" ? WORDS : []));
      if (!wordsList.length || start >= tokens.length) return { w: null, count: 0 };
      var best = { w: null, count: 0 };
      var phrase = "";
      for (var k = start; k < tokens.length; k++) {
        phrase = (phrase ? phrase + " " : "") + tokens[k];
        if (/^[.,!?]$/.test(tokens[k])) break;
        var matches = wordsList.filter(function(x) { return x && x.word && x.word.toLowerCase() === phrase.toLowerCase(); });
        var w = null;
        if (variantHint && matches.length > 1) {
          w = matches.find(function(x) { return x.soundFile && x.soundFile.indexOf(variantHint) >= 0; }) || matches[0];
        } else if (matches.length) {
          w = matches[0];
        }
        if (w) best = { w: w, count: k - start + 1 };
      }
      return best;
    }
    var wordIndex = 0;
    story.lines.forEach(function(line, lineIdx) {
      var leadingTab = "";
      var pendingOpeningQuote = "";
      if (typeof line === "string" && line.charAt(0) === "\t") {
        leadingTab = "\t";
        line = line.substring(1);
      }
      var tokens = (typeof line === "string" ? line.match(/[\p{L}']+|[.,!?]|[\u0022\u201C\u201D]/gu) : [line]) || [];
      // Merge 's tokens with the previous word token
      var mergedTokens = [];
      for (var ti = 0; ti < tokens.length; ti++) {
        var currentTok = tokens[ti];
        // If this token is "'s" (possessive) or just "s" after a word ending in apostrophe, merge with previous word
        if (mergedTokens.length > 0) {
          var prevTok = mergedTokens[mergedTokens.length - 1];
          // Check if previous token ends with apostrophe and current is "s", or current is "'s"
          if ((currentTok === "s" && /'$/.test(prevTok)) || currentTok === "'s") {
            // If previous token is a word (contains letters, not punctuation or quotes), merge 's with it
            if (/^[\p{L}']+$/u.test(prevTok) && !/^[.,!?]|[\u0022\u201C\u201D]$/.test(prevTok)) {
              // Remove trailing apostrophe if present, then add 's
              mergedTokens[mergedTokens.length - 1] = prevTok.replace(/'$/, '') + "'s";
              continue;
            }
          }
        }
        mergedTokens.push(currentTok);
      }
      tokens = mergedTokens;
    if (!tokens.length) tokens = [];
    if (leadingTab) {
      var tabSpan = document.createElement("span");
      tabSpan.style.whiteSpace = "pre";
      tabSpan.textContent = leadingTab;
      el.appendChild(tabSpan);
    }
    for (var j = 0; j < tokens.length; j++) {
      var tok = tokens[j];
      if (/^[\u0022\u201C\u201D]$/.test(tok)) {
        // Check if this is an opening quote (followed by a word) or closing quote
        var nextTok = j + 1 < tokens.length ? tokens[j + 1] : null;
        var prevTok = j > 0 ? tokens[j - 1] : null;
        // Opening quote: followed by a word AND not immediately preceded by punctuation attached to a word
        // Closing quote: preceded by punctuation that's attached to a word (like word!" or word.")
        // Exception: if quote follows sentence-ending punctuation (. ! ?) and is followed by a word starting a new sentence, it's opening
        var isPrecededByPunctuation = prevTok && /^[.,!?]$/.test(prevTok);
        var isFollowedByWord = nextTok && /^[\p{L}']+$/u.test(nextTok);
        // Check if previous element in DOM ends with punctuation (meaning punctuation is attached to word)
        var prevEl = el.lastChild;
        while (prevEl && prevEl.nodeType === 3) prevEl = prevEl.previousSibling;
        var prevEndsWithPunctuation = prevEl && prevEl.textContent && /[.,!?]$/.test(prevEl.textContent);
        // Opening if: followed by word AND previous element doesn't start with quote AND 
        //   (not preceded by punctuation OR preceded by punctuation that's a separate token, not attached)
        // Closing if: previous element starts with quote (closing quoted text like "free") 
        //   OR preceded by punctuation attached to word (like "Surprise!")
        var prevStartsWithQuote = prevEl && prevEl.textContent && /^[\u0022\u201C\u201D]/.test(prevEl.textContent);
        // Punctuation is separate if it's a token but not attached to previous element
        var punctuationIsSeparate = isPrecededByPunctuation && !prevEndsWithPunctuation;
        var isOpeningQuote = isFollowedByWord && !prevStartsWithQuote && (!isPrecededByPunctuation || punctuationIsSeparate);
        
        if (isOpeningQuote) {
          // Opening quote: store it to prepend to the next word
          pendingOpeningQuote = tok;
        } else {
          // Closing quote: attach to previous word or punctuation element
          var prev = el.lastChild;
          while (prev && prev.nodeType === 3) prev = prev.previousSibling;
          if (prev && prev.classList) {
            if (prev.classList.contains("word") || prev.classList.contains("punct")) {
              prev.textContent += tok;
              // Remove any space text node that might have been added after this element
              var nextSibling = prev.nextSibling;
              if (nextSibling && nextSibling.nodeType === 3 && nextSibling.textContent === " ") {
                el.removeChild(nextSibling);
              }
            } else {
              var sp = document.createElement("span");
              sp.className = "punct";
              sp.textContent = tok;
              el.appendChild(sp);
            }
          } else {
            var sp = document.createElement("span");
            sp.className = "punct";
            sp.textContent = tok;
            el.appendChild(sp);
          }
        }
      } else if (/^[.,!?]$/.test(tok)) {
        var prev = el.lastChild;
        while (prev && prev.nodeType === 3) prev = prev.previousSibling;
        if (prev && prev.classList && prev.classList.contains("word")) {
          prev.textContent += tok;
        } else {
          var sp = document.createElement("span");
          sp.className = "punct";
          if (/^[.!?]$/.test(tok)) sp.dataset.pause = "1";
          sp.textContent = tok;
          el.appendChild(sp);
        }
      } else {
        var heteronymOverride = (typeof getHeteronymOverride === "function" ? getHeteronymOverride(i, lineIdx, j) : null);
        var found = findWordEntry(tokens, j, heteronymOverride);
        var phraseCount = found.count;
        var displayText = phraseCount > 1 ? tokens.slice(j, j + phraseCount).join(" ") : tok;
        if (phraseCount > 1) j += phraseCount - 1;
        var w = found.w;
        var hasAudio = w && w.soundFile;
        var missingAudio = w && !hasAudio;
        var span = document.createElement("span");
        span.className = "word" + (missingAudio ? " word--unknown" : "");
        // Prepend any pending opening quote
        span.textContent = pendingOpeningQuote + displayText;
        pendingOpeningQuote = ""; // Clear after using
        span.dataset.word = displayText;
        if (w && w.soundFile) span.dataset.soundFile = w.soundFile;
        if (w && typeof w.volume === "number") span.dataset.volume = String(w.volume);
        var curIdx = wordIndex++;
        (function(ww) {
          span.onclick = function() {
            if (ww) {
              openInfo(typeof getWordInfoHtml === "function" ? getWordInfoHtml(ww) : "<h2>"+ww.word+"</h2><p>"+(state.phon==="IPA"?ww.ipa:ww.ce)+"</p><p>"+ww.jpWord+"</p><p>"+(state.lang==="EN"?ww.enDef:ww.jpDef)+"</p>");
            }
          };
        })(w);
        (function(spanEl, idx) {
          spanEl.oncontextmenu = function(e) {
            e.preventDefault();
            document.querySelectorAll(".word").forEach(function(x) { x.classList.remove("playing","highlighted"); });
            spanEl.classList.add("highlighted");
            state.autoIndex = idx;
          };
        })(span, curIdx);
        el.appendChild(span);
        // Check if we should add a space after this word
        var nextToken = j + 1 < tokens.length ? tokens[j + 1] : null;
        var nextNextToken = j + 2 < tokens.length ? tokens[j + 2] : null;
        
        // Don't add space if:
        // 1. Next token is punctuation
        // 2. Next token is any quote (opening or closing)
        // 3. This word starts with an opening quote (no space before opening quote)
        // 4. Previous element ends with a closing quote (no space after closing quote)
        var isNextOpeningQuote = nextToken && /^[\u0022\u201C\u201D]$/.test(nextToken) && 
                                 nextNextToken && /^[\p{L}']+$/u.test(nextNextToken);
        var thisWordStartsWithQuote = span.textContent && /^[\u0022\u201C\u201D]/.test(span.textContent);
        // Check previous element (skipping text nodes/spaces) to see if it ends with a quote
        var prevEl = span.previousSibling;
        while (prevEl && prevEl.nodeType === 3) prevEl = prevEl.previousSibling;
        var prevEndsWithQuote = prevEl && prevEl.textContent && /[\u0022\u201C\u201D]$/.test(prevEl.textContent);
        
        // If previous element ends with a quote, remove any space text node between them
        if (prevEndsWithQuote) {
          // Check the immediate previous sibling (which should be a space text node if it exists)
          var immediatePrev = span.previousSibling;
          if (immediatePrev && immediatePrev.nodeType === 3 && immediatePrev.textContent === " ") {
            el.removeChild(immediatePrev);
          }
        }
        
        if (nextToken && !/^[.,!?]$/.test(nextToken) && !/^[\u0022\u201C\u201D]$/.test(nextToken) && !isNextOpeningQuote && !thisWordStartsWithQuote && !prevEndsWithQuote) {
          el.appendChild(document.createTextNode(" "));
        }
      }
    }
    el.appendChild(document.createElement("br"));
    });
    document.querySelectorAll(".screen").forEach(function(s) { s.classList.remove("active"); });
    document.getElementById("storyScreen").classList.add("active");
  }
  if (i === 0 && state.fullDictOnlyMissingAudio && typeof buildAudioExistsCache === "function") {
    if (typeof invalidateAudioExistsCache === "function") invalidateAudioExistsCache();
    buildAudioExistsCache(doOpen);
  } else {
    doOpen();
  }
}

/* ================= RENDER UI ================= */
function renderUI(){
 const t=TEXT[state.lang];
 $("title").textContent=t.title;
 $("btnSounds").textContent=t.sounds;
 $("btnVocab").textContent=t.vocab;
 $("btnReading").textContent=t.reading;
 $("btnDict").textContent=t.dict;
 $("sndBack").textContent="←";
 $("sndTitle").textContent=t.sounds;
 $("sndPractice").textContent=t.practice;
 $("vocabTitle").textContent=t.practice;
 $("speakBtn").textContent=t.speaking;
 $("listenBtn").textContent=t.listening;
 $("bothBtn").textContent=t.both;
 $("lblMax").textContent=t.max;
 $("lblReal").textContent=t.real;

 [...$("maxSounds").options].forEach(o=>{
  if(o.value==="Any") o.textContent=t.any;
 });

 $("practiceBack").textContent="←";
 $("readingTitle").textContent=t.stories;
 if ($("storySearch")) $("storySearch").placeholder = t.storySearchPlaceholder || "Search stories…";
 if ($("readingCefrLabel")) $("readingCefrLabel").textContent = t.readingCefrLabel || "CEFR (for Full Dictionary):";
 renderStoryList();
 $("dictTitle").textContent=t.dict;
 $("dictSearch").placeholder=t.search;
 $("langBtn").textContent=state.lang==="EN"?"日本語に切り替える":"Switch to English";
 $("phonBtn").textContent=state.phon==="IPA"?"IPA Phonetics":"CE Phonetics";
 $("colorModeBtn").textContent=state.colorMode?t.colorOn:t.colorOff;
 $("autoReadBtn").textContent=state.autoReading?t.paused:t.auto;
 renderDictionary();
}
function renderStoryList() {
  var list = document.getElementById("storyList");
  if (!list || typeof STORIES === "undefined") return;
  var q = ($("storySearch") && $("storySearch").value || "").trim().toLowerCase();
  list.innerHTML = "";
  list.className = "story-grid";
  var filtered = [];
  for (var i = 1; i < STORIES.length; i++) {
    var s = STORIES[i];
    var title = s.title || "";
    if (q && title.toLowerCase().indexOf(q) === -1) continue;
    if (s.cefr && !state.readingCefrFilter.has(s.cefr)) continue;
    filtered.push({ story: s, index: i });
  }
  filtered.sort(function(a, b) {
    return (a.story.title || "").toLowerCase().localeCompare((b.story.title || "").toLowerCase());
  });
  filtered.forEach(function(item) {
    var btn = document.createElement("button");
    btn.textContent = item.story.title;
    btn.className = "story-btn";
    if (item.story.cefr) {
      btn.className += " story-cefr-" + item.story.cefr.toLowerCase();
    }
    (function(idx) { btn.onclick = function() { openStory(idx); }; })(item.index);
    list.appendChild(btn);
  });
}

function initReadingCefrFilters() {
  var container = document.getElementById("readingCefrFilters");
  if (!container || container.children.length) return;
  var levels = ["A1","A2","B1","B2","C1"];
  var colors = {
    "A1": { bg: "#e6d9f2", border: "#d4b3e8" },
    "A2": { bg: "#d9e6f2", border: "#b3d4e8" },
    "B1": { bg: "#d9f2e6", border: "#b3e8d4" },
    "B2": { bg: "#f2f2d9", border: "#e8e8b3" },
    "C1": { bg: "#f2d9d9", border: "#e8b3b3" }
  };
  levels.forEach(function(c) {
    var label = document.createElement("label");
    label.className = "cefr-label cefr-" + c.toLowerCase();
    var cb = document.createElement("input");
    cb.type = "checkbox";
    cb.checked = state.readingCefrFilter.has(c);
    cb.onchange = function() {
      if (cb.checked) state.readingCefrFilter.add(c);
      else state.readingCefrFilter.delete(c);
      renderStoryList();
    };
    label.appendChild(cb);
    label.appendChild(document.createTextNode(" " + c));
    container.appendChild(label);
  });
}

renderUI();
initReadingCefrFilters();
renderStoryList();

(function renderAlphabet() {
    const alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".split("");
    const grid = $("alphabetGrid");
    if (!grid) {
        console.error("alphabetGrid not found!");
        return;
    }

    const borders = {
        red: ["A","E","I","O","U"],
        orange: ["L","R","W","Y"],
        yellow: ["C","Q","X","?"]
    };

    grid.innerHTML = "";

    alphabet.forEach(letter => {
        const d = document.createElement("div");

        // Color logic (uppercase only)
        const b = Object.keys(borders).find(k => borders[k].includes(letter)) || "black";
        d.className = "tile " + b;

        // Display Aa, Bb, etc
        d.textContent = letter + " " + letter.toLowerCase();

        d.onclick = () => {
            let h = 0, s = 0, e = 0;
            if (typeof WORDS !== "undefined" && Array.isArray(WORDS)) {
                WORDS.forEach(w => {
                    if (w && w.word && w.tallies && w.word.toUpperCase().includes(letter)) {
                        h += (w.tallies.hard || 0);
                        s += (w.tallies.skip || 0);
                        e += (w.tallies.easy || 0);
                    }
                });
            }

            const videoPath = `videos/animated_${letter.toLowerCase()}.mp4`;

            // -------- LOAD NOTES --------
            const notesFallback = '<p style="opacity:0.6">Notes coming soon for ' + letter + '</p>';
            let notesHTML = notesFallback;

if (letter === "A" && typeof LETTER_NOTES_A === "function") { try { const n = LETTER_NOTES_A(letter); notesHTML = (n && String(n).trim()) ? '<div class="letter-notes letter-notes-content">' + n + '</div>' : notesFallback; } catch (e) { notesHTML = notesFallback; } }
if (letter === "B" && typeof LETTER_NOTES_B === "function") { try { const n = LETTER_NOTES_B(letter); notesHTML = (n && String(n).trim()) ? '<div class="letter-notes letter-notes-content">' + n + '</div>' : notesFallback; } catch (e) { notesHTML = notesFallback; } }
if (letter === "C" && typeof LETTER_NOTES_C === "function") { try { const n = LETTER_NOTES_C(letter); notesHTML = (n && String(n).trim()) ? '<div class="letter-notes letter-notes-content">' + n + '</div>' : notesFallback; } catch (e) { notesHTML = notesFallback; } }
if (letter === "D" && typeof LETTER_NOTES_D === "function") { try { const n = LETTER_NOTES_D(letter); notesHTML = (n && String(n).trim()) ? '<div class="letter-notes letter-notes-content">' + n + '</div>' : notesFallback; } catch (e) { notesHTML = notesFallback; } }
if (letter === "E" && typeof LETTER_NOTES_E === "function") { try { const n = LETTER_NOTES_E(letter); notesHTML = (n && String(n).trim()) ? '<div class="letter-notes letter-notes-content">' + n + '</div>' : notesFallback; } catch (e) { notesHTML = notesFallback; } }
if (letter === "F" && typeof LETTER_NOTES_F === "function") { try { const n = LETTER_NOTES_F(letter); notesHTML = (n && String(n).trim()) ? '<div class="letter-notes letter-notes-content">' + n + '</div>' : notesFallback; } catch (e) { notesHTML = notesFallback; } }
if (letter === "G" && typeof LETTER_NOTES_G === "function") { try { const n = LETTER_NOTES_G(letter); notesHTML = (n && String(n).trim()) ? '<div class="letter-notes letter-notes-content">' + n + '</div>' : notesFallback; } catch (e) { notesHTML = notesFallback; } }
if (letter === "H" && typeof LETTER_NOTES_H === "function") { try { const n = LETTER_NOTES_H(letter); notesHTML = (n && String(n).trim()) ? '<div class="letter-notes letter-notes-content">' + n + '</div>' : notesFallback; } catch (e) { notesHTML = notesFallback; } }
if (letter === "I" && typeof LETTER_NOTES_I === "function") { try { const n = LETTER_NOTES_I(letter); notesHTML = (n && String(n).trim()) ? '<div class="letter-notes letter-notes-content">' + n + '</div>' : notesFallback; } catch (e) { notesHTML = notesFallback; } }
if (letter === "J" && typeof LETTER_NOTES_J === "function") { try { const n = LETTER_NOTES_J(letter); notesHTML = (n && String(n).trim()) ? '<div class="letter-notes letter-notes-content">' + n + '</div>' : notesFallback; } catch (e) { notesHTML = notesFallback; } }
if (letter === "K" && typeof LETTER_NOTES_K === "function") { try { const n = LETTER_NOTES_K(letter); notesHTML = (n && String(n).trim()) ? '<div class="letter-notes letter-notes-content">' + n + '</div>' : notesFallback; } catch (e) { notesHTML = notesFallback; } }
if (letter === "L" && typeof LETTER_NOTES_L === "function") { try { const n = LETTER_NOTES_L(letter); notesHTML = (n && String(n).trim()) ? '<div class="letter-notes letter-notes-content">' + n + '</div>' : notesFallback; } catch (e) { notesHTML = notesFallback; } }
if (letter === "M" && typeof LETTER_NOTES_M === "function") { try { const n = LETTER_NOTES_M(letter); notesHTML = (n && String(n).trim()) ? '<div class="letter-notes letter-notes-content">' + n + '</div>' : notesFallback; } catch (e) { notesHTML = notesFallback; } }
if (letter === "N" && typeof LETTER_NOTES_N === "function") { try { const n = LETTER_NOTES_N(letter); notesHTML = (n && String(n).trim()) ? '<div class="letter-notes letter-notes-content">' + n + '</div>' : notesFallback; } catch (e) { notesHTML = notesFallback; } }
if (letter === "O" && typeof LETTER_NOTES_O === "function") { try { const n = LETTER_NOTES_O(letter); notesHTML = (n && String(n).trim()) ? '<div class="letter-notes letter-notes-content">' + n + '</div>' : notesFallback; } catch (e) { notesHTML = notesFallback; } }
if (letter === "P" && typeof LETTER_NOTES_P === "function") { try { const n = LETTER_NOTES_P(letter); notesHTML = (n && String(n).trim()) ? '<div class="letter-notes letter-notes-content">' + n + '</div>' : notesFallback; } catch (e) { notesHTML = notesFallback; } }
if (letter === "Q" && typeof LETTER_NOTES_Q === "function") { try { const n = LETTER_NOTES_Q(letter); notesHTML = (n && String(n).trim()) ? '<div class="letter-notes letter-notes-content">' + n + '</div>' : notesFallback; } catch (e) { notesHTML = notesFallback; } }
if (letter === "R" && typeof LETTER_NOTES_R === "function") { try { const n = LETTER_NOTES_R(letter); notesHTML = (n && String(n).trim()) ? '<div class="letter-notes letter-notes-content">' + n + '</div>' : notesFallback; } catch (e) { notesHTML = notesFallback; } }
if (letter === "S" && typeof LETTER_NOTES_S === "function") { try { const n = LETTER_NOTES_S(letter); notesHTML = (n && String(n).trim()) ? '<div class="letter-notes letter-notes-content">' + n + '</div>' : notesFallback; } catch (e) { notesHTML = notesFallback; } }
if (letter === "T" && typeof LETTER_NOTES_T === "function") { try { const n = LETTER_NOTES_T(letter); notesHTML = (n && String(n).trim()) ? '<div class="letter-notes letter-notes-content">' + n + '</div>' : notesFallback; } catch (e) { notesHTML = notesFallback; } }
if (letter === "U" && typeof LETTER_NOTES_U === "function") { try { const n = LETTER_NOTES_U(letter); notesHTML = (n && String(n).trim()) ? '<div class="letter-notes letter-notes-content">' + n + '</div>' : notesFallback; } catch (e) { notesHTML = notesFallback; } }
if (letter === "V" && typeof LETTER_NOTES_V === "function") { try { const n = LETTER_NOTES_V(letter); notesHTML = (n && String(n).trim()) ? '<div class="letter-notes letter-notes-content">' + n + '</div>' : notesFallback; } catch (e) { notesHTML = notesFallback; } }
if (letter === "W" && typeof LETTER_NOTES_W === "function") { try { const n = LETTER_NOTES_W(letter); notesHTML = (n && String(n).trim()) ? '<div class="letter-notes letter-notes-content">' + n + '</div>' : notesFallback; } catch (e) { notesHTML = notesFallback; } }
if (letter === "X" && typeof LETTER_NOTES_X === "function") { try { const n = LETTER_NOTES_X(letter); notesHTML = (n && String(n).trim()) ? '<div class="letter-notes letter-notes-content">' + n + '</div>' : notesFallback; } catch (e) { notesHTML = notesFallback; } }
if (letter === "Y" && typeof LETTER_NOTES_Y === "function") { try { const n = LETTER_NOTES_Y(letter); notesHTML = (n && String(n).trim()) ? '<div class="letter-notes letter-notes-content">' + n + '</div>' : notesFallback; } catch (e) { notesHTML = notesFallback; } }
if (letter === "Z" && typeof LETTER_NOTES_Z === "function") { try { const n = LETTER_NOTES_Z(letter); notesHTML = (n && String(n).trim()) ? '<div class="letter-notes letter-notes-content">' + n + '</div>' : notesFallback; } catch (e) { notesHTML = notesFallback; } }

            // -------- FINAL POPUP ORDER: VIDEO → NOTES → TALLIES (no example sentences) --------
            const t = (typeof TEXT !== "undefined" && state && TEXT[state.lang]) ? TEXT[state.lang] : { hard: "Hard", skip: "Skip", easy: "Easy" };
            const letterTitle = (d && d.textContent) ? d.textContent : (letter + " " + letter.toLowerCase());
            try {
                // Build HTML with concatenation so notes content (which may contain ` or ${) cannot break the string
                const popupHtml =
                    '<div class="letter-popup-wrapper">' +
                    '<div class="videoBox" onclick="this.classList.toggle(\'fullscreen\')">' +
                    '<video autoplay loop muted playsinline><source src="' + videoPath + '" type="video/mp4"></video></div>' +
                    '<h2>' + letterTitle + '</h2>' +
                    '<div class="letter-notes-scroll">' + (notesHTML || notesFallback) + '</div>' +
                    '<hr><p class="letter-tallies">' + t.hard + ': ' + h + '<br>' + t.skip + ': ' + s + '<br>' + t.easy + ': ' + e + '</p></div>';
                openInfo(popupHtml);
            } catch (err) {
                console.error("Letter popup error:", err);
                openInfo('<h2>' + letterTitle + '</h2><p>Notes coming soon.</p><p>' + t.hard + ': ' + h + ' | ' + t.skip + ': ' + s + ' | ' + t.easy + ': ' + e + '</p>');
            }
        };

        d.oncontextmenu = e => {
            e.preventDefault();
            d.classList.toggle("highlighted");
        };

        grid.appendChild(d);
    });
})();

/* ================= SOUNDS ================= */
const SOUNDS=[
 {s:"i",t:"v"},{s:"ɪ",t:"v"},{s:"e",t:"v"},{s:"ɛ",t:"v"},
 {s:"æ",t:"v"},{s:"ɑ",t:"v"},{s:"ɔ",t:"v"},{s:"o",t:"v"},
 {s:"ʊ",t:"v"},{s:"u",t:"v"},{s:"ʌ",t:"v"},{s:"ə",t:"v"},
 {s:"aɪ",t:"v"},{s:"aʊ",t:"v"},{s:"ɔɪ",t:"v"},
 {s:"p"},{s:"b"},{s:"t"},{s:"d"},{s:"k"},{s:"g"},
 {s:"f"},{s:"v"},{s:"θ"},{s:"ð"},{s:"s"},{s:"z"},
 {s:"ʃ"},{s:"ʒ"},{s:"h"},{s:"m"},{s:"n"},{s:"ŋ"},
 {s:"l",t:"lrwy"},{s:"r",t:"lrwy"},{s:"w",t:"lrwy"},{s:"j",t:"lrwy"}
];
const CE_MAP={"θ":"th","ð":"th","ʃ":"sh","ʒ":"zh","ŋ":"ng","j":"y"};

function renderSounds(){
 $("soundsGrid").innerHTML="";
 SOUNDS.forEach(o=>{
  const d=document.createElement("div");
  const cls=o.t==="v"?"red":o.t==="lrwy"?"orange":"black";
  d.className="tile "+cls;
  d.textContent= state.phon==="IPA"?o.s:(CE_MAP[o.s]||o.s);
  d.onclick=()=>openInfo(`<h2>${d.textContent}</h2>`);
  d.oncontextmenu=e=>{e.preventDefault();d.classList.toggle("highlighted");};
  $("soundsGrid").appendChild(d);
 });
}
renderSounds();

const CEFRS=["A1","A2","B1","B2","C1","Unlisted","Undefined"];
CEFRS.forEach(c=>{
 const label=document.createElement("label");
 const cb=document.createElement("input");
 cb.type="checkbox"; cb.checked=true;
 cb.onchange=()=>{ cb.checked?state.cefrFilter.add(c):state.cefrFilter.delete(c); renderDictionary(); };
 label.appendChild(cb); label.append(" "+c+" ");
 $("cefrButtons").appendChild(label);
});

function updateFAQButtons(){
 $("faq0").textContent = state.lang==="EN"?FAQ[0].enQ:FAQ[0].jpQ;
 $("faq1").textContent = state.lang==="EN"?FAQ[1].enQ:FAQ[1].jpQ;
 $("faq2").textContent = state.lang==="EN"?FAQ[2].enQ:FAQ[2].jpQ;
}
updateFAQButtons();

//8
</script>
</body>
</html>
